// Code generated by sqlc. DO NOT EDIT.
// source: sagas.sql

package postgres

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const createSaga = `-- name: CreateSaga :one
INSERT INTO sagas (name, formatted_name, payload)
VALUES ($1, $2, $3) RETURNING saga_id, name, formatted_name, payload, created_at
`

type CreateSagaParams struct {
	Name          string          `db:"name"`
	FormattedName string          `db:"formatted_name"`
	Payload       json.RawMessage `db:"payload"`
}

func (q *Queries) CreateSaga(ctx context.Context, arg CreateSagaParams) (Saga, error) {
	row := q.db.QueryRow(ctx, createSaga, arg.Name, arg.FormattedName, arg.Payload)
	var i Saga
	err := row.Scan(
		&i.SagaID,
		&i.Name,
		&i.FormattedName,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const createSagaExecution = `-- name: CreateSagaExecution :one
INSERT INTO saga_executions (saga_id, payload)
VALUES ($1, $2) RETURNING saga_execution_id, saga_id, payload, created_at
`

type CreateSagaExecutionParams struct {
	SagaID  uuid.UUID       `db:"saga_id"`
	Payload json.RawMessage `db:"payload"`
}

func (q *Queries) CreateSagaExecution(ctx context.Context, arg CreateSagaExecutionParams) (SagaExecution, error) {
	row := q.db.QueryRow(ctx, createSagaExecution, arg.SagaID, arg.Payload)
	var i SagaExecution
	err := row.Scan(
		&i.SagaExecutionID,
		&i.SagaID,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const createSagaSteps = `-- name: CreateSagaSteps :many
INSERT INTO saga_steps(saga_id, index, name)
SELECT
    unnest($1::uuid[]) AS saga_id,
    unnest($2::INTEGER[]) as index,
    unnest($3::TEXT[]) AS name
RETURNING step_id, saga_id, index, name
`

type CreateSagaStepsParams struct {
	SagaIds []uuid.UUID `db:"saga_ids"`
	Indexes []int32     `db:"indexes"`
	Names   []string    `db:"names"`
}

func (q *Queries) CreateSagaSteps(ctx context.Context, arg CreateSagaStepsParams) ([]SagaStep, error) {
	rows, err := q.db.Query(ctx, createSagaSteps, arg.SagaIds, arg.Indexes, arg.Names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SagaStep{}
	for rows.Next() {
		var i SagaStep
		if err := rows.Scan(
			&i.StepID,
			&i.SagaID,
			&i.Index,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createSagaStepsExecution = `-- name: CreateSagaStepsExecution :many
INSERT INTO step_executions(saga_execution_id, index, name, status)
SELECT
   unnest($1::uuid[]) AS saga_execution_id,
   unnest($2::INTEGER[]) as index,
   unnest($3::TEXT[]) AS name,
   unnest($4::TEXT[]) as status
RETURNING step_execution_id, saga_execution_id, index, name, status
`

type CreateSagaStepsExecutionParams struct {
	SagaExecutionIds []uuid.UUID `db:"saga_execution_ids"`
	Indexes          []int32     `db:"indexes"`
	Names            []string    `db:"names"`
	Statuses         []string    `db:"statuses"`
}

func (q *Queries) CreateSagaStepsExecution(ctx context.Context, arg CreateSagaStepsExecutionParams) ([]StepExecution, error) {
	rows, err := q.db.Query(ctx, createSagaStepsExecution,
		arg.SagaExecutionIds,
		arg.Indexes,
		arg.Names,
		arg.Statuses,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StepExecution{}
	for rows.Next() {
		var i StepExecution
		if err := rows.Scan(
			&i.StepExecutionID,
			&i.SagaExecutionID,
			&i.Index,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSaga = `-- name: GetSaga :one
SELECT saga_id, name, formatted_name, payload, created_at FROM sagas WHERE saga_id = $1
`

func (q *Queries) GetSaga(ctx context.Context, sagaID uuid.UUID) (Saga, error) {
	row := q.db.QueryRow(ctx, getSaga, sagaID)
	var i Saga
	err := row.Scan(
		&i.SagaID,
		&i.Name,
		&i.FormattedName,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const getSagaExecution = `-- name: GetSagaExecution :one
SELECT saga_execution_id, saga_id, payload, created_at FROM saga_executions WHERE saga_execution_id = $1
`

func (q *Queries) GetSagaExecution(ctx context.Context, sagaExecutionID uuid.UUID) (SagaExecution, error) {
	row := q.db.QueryRow(ctx, getSagaExecution, sagaExecutionID)
	var i SagaExecution
	err := row.Scan(
		&i.SagaExecutionID,
		&i.SagaID,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const getSagaStepsBySagaID = `-- name: GetSagaStepsBySagaID :many
SELECT step_id, saga_id, index, name FROM saga_steps WHERE saga_id = $1
`

func (q *Queries) GetSagaStepsBySagaID(ctx context.Context, sagaID uuid.UUID) ([]SagaStep, error) {
	rows, err := q.db.Query(ctx, getSagaStepsBySagaID, sagaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SagaStep{}
	for rows.Next() {
		var i SagaStep
		if err := rows.Scan(
			&i.StepID,
			&i.SagaID,
			&i.Index,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSagaStepsExecutionByExecutionID = `-- name: GetSagaStepsExecutionByExecutionID :many
SELECT step_execution_id, saga_execution_id, index, name, status FROM step_executions WHERE saga_execution_id = $1 ORDER BY index
`

func (q *Queries) GetSagaStepsExecutionByExecutionID(ctx context.Context, sagaExecutionID uuid.UUID) ([]StepExecution, error) {
	rows, err := q.db.Query(ctx, getSagaStepsExecutionByExecutionID, sagaExecutionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StepExecution{}
	for rows.Next() {
		var i StepExecution
		if err := rows.Scan(
			&i.StepExecutionID,
			&i.SagaExecutionID,
			&i.Index,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setSagaStepExecutionStatus = `-- name: SetSagaStepExecutionStatus :exec
UPDATE step_executions SET status = $1 WHERE index = $2 AND saga_execution_id = $3
`

type SetSagaStepExecutionStatusParams struct {
	Status          string    `db:"status"`
	Index           int32     `db:"index"`
	SagaExecutionID uuid.UUID `db:"saga_execution_id"`
}

func (q *Queries) SetSagaStepExecutionStatus(ctx context.Context, arg SetSagaStepExecutionStatusParams) error {
	_, err := q.db.Exec(ctx, setSagaStepExecutionStatus, arg.Status, arg.Index, arg.SagaExecutionID)
	return err
}
